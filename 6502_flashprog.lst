
6502_flashprog.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
void handle_reset( void ) __attribute__((section(".text.handle_reset")));

void InterruptVectorDefault( void )
{
#if !defined(FUNCONF_TINYVECTOR) || !FUNCONF_TINYVECTOR
	asm volatile( DEFAULT_INTERRUPT_VECTOR_CONTENTS );
   0:	1380006f          	j	138 <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	000001f4          	.word	0x000001f4
   c:	000001a8          	.word	0x000001a8
  10:	00000000          	.word	0x00000000
  14:	000001a8          	.word	0x000001a8
	...
  20:	000001a8          	.word	0x000001a8
  24:	000001a8          	.word	0x000001a8
	...
  30:	000001a8          	.word	0x000001a8
  34:	00000000          	.word	0x00000000
  38:	000001a8          	.word	0x000001a8
  3c:	00000000          	.word	0x00000000
  40:	000001a8          	.word	0x000001a8
  44:	000001a8          	.word	0x000001a8
  48:	000001a8          	.word	0x000001a8
  4c:	000001a8          	.word	0x000001a8
  50:	000001a8          	.word	0x000001a8
  54:	000001a8          	.word	0x000001a8
  58:	000001a8          	.word	0x000001a8
  5c:	000001a8          	.word	0x000001a8
  60:	000001a8          	.word	0x000001a8
  64:	000001a8          	.word	0x000001a8
  68:	000001a8          	.word	0x000001a8
  6c:	000001a8          	.word	0x000001a8
  70:	000001a8          	.word	0x000001a8
  74:	000001a8          	.word	0x000001a8
  78:	000001a8          	.word	0x000001a8
  7c:	000001a8          	.word	0x000001a8
  80:	000001a8          	.word	0x000001a8
  84:	000001a8          	.word	0x000001a8
  88:	000001a8          	.word	0x000001a8
  8c:	000001a8          	.word	0x000001a8
  90:	000001a8          	.word	0x000001a8
  94:	000001a8          	.word	0x000001a8
  98:	000001a8          	.word	0x000001a8
  9c:	000001a8          	.word	0x000001a8
  a0:	000001a8          	.word	0x000001a8
  a4:	000001a8          	.word	0x000001a8
  a8:	000001a8          	.word	0x000001a8
  ac:	000001a8          	.word	0x000001a8
  b0:	000001a8          	.word	0x000001a8
  b4:	000001a8          	.word	0x000001a8
  b8:	000001a8          	.word	0x000001a8
  bc:	000001a8          	.word	0x000001a8
  c0:	000001a8          	.word	0x000001a8
  c4:	000001a8          	.word	0x000001a8
  c8:	000001a8          	.word	0x000001a8
  cc:	000001a8          	.word	0x000001a8
  d0:	000001a8          	.word	0x000001a8
  d4:	000001a8          	.word	0x000001a8
  d8:	000001a8          	.word	0x000001a8
  dc:	0000                	.insn	2, 0x
	...

Disassembly of section .text:

000000e0 <PrintHex>:
	while( (*DMDATA0) & 0x80 );
  e0:	e00007b7          	lui	a5,0xe0000
  e4:	38078793          	addi	a5,a5,896 # e0000380 <_eusrstack+0xbfffb380>
  e8:	4398                	lw	a4,0(a5)
  ea:	08077713          	andi	a4,a4,128
  ee:	ff6d                	bnez	a4,e8 <PrintHex+0x8>
	*DMDATA0 = 0x78302088; //" 0x"
  f0:	78302737          	lui	a4,0x78302
  f4:	08870713          	addi	a4,a4,136 # 78302088 <_eusrstack+0x582fd088>
		while( (*DMDATA0) & 0x80 );
  f8:	e00006b7          	lui	a3,0xe0000
	*DMDATA0 = 0x78302088; //" 0x"
  fc:	c398                	sw	a4,0(a5)
		while( (*DMDATA0) & 0x80 );
  fe:	38068693          	addi	a3,a3,896 # e0000380 <_eusrstack+0xbfffb380>
	for( shift = 28; shift >= 0; shift -= 4 )
 102:	4771                	li	a4,28
		s += ( s < 10 ) ? '0' : ('a' - 10);
 104:	4825                	li	a6,9
	for( shift = 28; shift >= 0; shift -= 4 )
 106:	55f1                	li	a1,-4
		while( (*DMDATA0) & 0x80 );
 108:	429c                	lw	a5,0(a3)
 10a:	0807f793          	andi	a5,a5,128
 10e:	ffed                	bnez	a5,108 <PrintHex+0x28>
		int s = (n>>shift) & 0xf;
 110:	00e55633          	srl	a2,a0,a4
 114:	8a3d                	andi	a2,a2,15
		s += ( s < 10 ) ? '0' : ('a' - 10);
 116:	00c837b3          	sltu	a5,a6,a2
 11a:	40f007b3          	neg	a5,a5
 11e:	0277f793          	andi	a5,a5,39
 122:	03078793          	addi	a5,a5,48
 126:	97b2                	add	a5,a5,a2
		*DMDATA0 = 0x85 | (s<<8); //" 0x"
 128:	07a2                	slli	a5,a5,0x8
 12a:	0857e793          	ori	a5,a5,133
 12e:	c29c                	sw	a5,0(a3)
	for( shift = 28; shift >= 0; shift -= 4 )
 130:	1771                	addi	a4,a4,-4
 132:	fcb71be3          	bne	a4,a1,108 <PrintHex+0x28>
}
 136:	8082                	ret

00000138 <handle_reset>:

#if defined( CH32V003 ) || defined( CH32X03x ) || defined(CH32V00x)

void handle_reset( void )
{
	asm volatile( "\n\
 138:	20000197          	auipc	gp,0x20000
 13c:	2c418193          	addi	gp,gp,708 # 200003fc <__global_pointer$>
 140:	20005117          	auipc	sp,0x20005
 144:	ec010113          	addi	sp,sp,-320 # 20005000 <_eusrstack>
 148:	6509                	lui	a0,0x2
 14a:	88050513          	addi	a0,a0,-1920 # 1880 <ch32fun.c.ce68a4cb+0x916>
 14e:	30051073          	csrw	mstatus,a0
 152:	468d                	li	a3,3
 154:	00000517          	auipc	a0,0x0
 158:	eac50513          	addi	a0,a0,-340 # 0 <InterruptVector>
 15c:	8d55                	or	a0,a0,a3
 15e:	30551073          	csrw	mtvec,a0
	csrw mtvec, a0\n" 
	: : : "a0", "a3", "memory");

	// Careful: Use registers to prevent overwriting of self-data.
	// This clears out BSS.
asm volatile(
 162:	c0418513          	addi	a0,gp,-1020 # 20000000 <_data_vma>
 166:	c0418593          	addi	a1,gp,-1020 # 20000000 <_data_vma>
 16a:	4601                	li	a2,0
 16c:	00b55663          	bge	a0,a1,178 <handle_reset+0x40>
 170:	c110                	sw	a2,0(a0)
 172:	0511                	addi	a0,a0,4
 174:	feb54ee3          	blt	a0,a1,170 <handle_reset+0x38>
 178:	28000513          	li	a0,640
 17c:	c0418593          	addi	a1,gp,-1020 # 20000000 <_data_vma>
 180:	c0418613          	addi	a2,gp,-1020 # 20000000 <_data_vma>
 184:	00c58863          	beq	a1,a2,194 <handle_reset+0x5c>
 188:	4114                	lw	a3,0(a0)
 18a:	c194                	sw	a3,0(a1)
 18c:	0511                	addi	a0,a0,4
 18e:	0591                	addi	a1,a1,4
 190:	fec59ae3          	bne	a1,a2,184 <handle_reset+0x4c>
);

#if defined( FUNCONF_SYSTICK_USE_HCLK ) && FUNCONF_SYSTICK_USE_HCLK
	SysTick->CTLR = 5;
#else
	SysTick->CTLR = 1;
 194:	e000f7b7          	lui	a5,0xe000f
 198:	4705                	li	a4,1
 19a:	c398                	sw	a4,0(a5)
#endif

	// set mepc to be main as the root app.
asm volatile(
 19c:	23400793          	li	a5,564
 1a0:	34179073          	csrw	mepc,a5
 1a4:	30200073          	mret

000001a8 <ADC1_2_IRQHandler>:

// Return the Machine Exception Program Register (MEPC)
static inline uint32_t __get_MEPC(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mepc" : "=r"(result));
 1a8:	34102573          	csrr	a0,mepc
	PrintHex( __get_MEPC() ); // "addr2line -e debugprintfdemo.elf 0x000007e6" ---> debugprintfdemo.c:45
 1ac:	3f15                	jal	e0 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0, mstatus": "=r"(result) );
 1ae:	30002573          	csrr	a0,mstatus
	PrintHex( __get_MSTATUS() );
 1b2:	373d                	jal	e0 <PrintHex>

// Return the Machine Trap Value Register (MTVAL)
static inline uint32_t __get_MTVAL(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mtval" : "=r" (result) );
 1b4:	34302573          	csrr	a0,mtval
	PrintHex( __get_MTVAL() );
 1b8:	3725                	jal	e0 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mcause": "=r"(result));
 1ba:	34202573          	csrr	a0,mcause
	PrintHex( __get_MCAUSE() );
 1be:	370d                	jal	e0 <PrintHex>
	while( (*DMDATA0) & 0x80 );
 1c0:	e00007b7          	lui	a5,0xe0000
 1c4:	38078793          	addi	a5,a5,896 # e0000380 <_eusrstack+0xbfffb380>
 1c8:	4398                	lw	a4,0(a5)
 1ca:	08077713          	andi	a4,a4,128
 1ce:	ff6d                	bnez	a4,1c8 <ADC1_2_IRQHandler+0x20>
	*DMDATA0 = 0x0a85;
 1d0:	6705                	lui	a4,0x1
 1d2:	a8570713          	addi	a4,a4,-1403 # a85 <_data_lma+0x805>
 1d6:	c398                	sw	a4,0(a5)
	while( (*DMDATA0) & 0x80 );
 1d8:	e00007b7          	lui	a5,0xe0000
 1dc:	38078793          	addi	a5,a5,896 # e0000380 <_eusrstack+0xbfffb380>
 1e0:	4398                	lw	a4,0(a5)
 1e2:	08077713          	andi	a4,a4,128
 1e6:	ff6d                	bnez	a4,1e0 <ADC1_2_IRQHandler+0x38>
	*DMDATA0 = 0xaaaaaa83;
 1e8:	aaaab737          	lui	a4,0xaaaab
 1ec:	a8370713          	addi	a4,a4,-1405 # aaaaaa83 <_eusrstack+0x8aaa5a83>
 1f0:	c398                	sw	a4,0(a5)
	asm volatile( "1: j 1b" );
 1f2:	a001                	j	1f2 <ADC1_2_IRQHandler+0x4a>

000001f4 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 1f4:	40021737          	lui	a4,0x40021
 1f8:	471c                	lw	a5,8(a4)
 1fa:	008006b7          	lui	a3,0x800
 1fe:	8fd5                	or	a5,a5,a3
 200:	c71c                	sw	a5,8(a4)

00000202 <SystemInit>:
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_0;
	#endif
#elif defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
 202:	400227b7          	lui	a5,0x40022
 206:	4709                	li	a4,2
 208:	c398                	sw	a4,0(a5)
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
	#else
		RCC->CFGR0 = RCC_HPRE_DIV1;                               	// PLLCLK = HCLK = SYSCLK = APB1
 20a:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION;     					// Use HSI, Only.
 20e:	00080737          	lui	a4,0x80
		RCC->CFGR0 = RCC_HPRE_DIV1;                               	// PLLCLK = HCLK = SYSCLK = APB1
 212:	0007a223          	sw	zero,4(a5) # 40021004 <_eusrstack+0x2001c004>
		RCC->CTLR  = BASE_CTLR | RCC_HSION;     					// Use HSI, Only.
 216:	08170713          	addi	a4,a4,129 # 80081 <g6502_flashprog.c.a4e91263+0x7e09d>
 21a:	c398                	sw	a4,0(a5)
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

#if !defined(CH57x) && !defined(CH58x) && !defined(CH59x)
	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 21c:	009f0737          	lui	a4,0x9f0
 220:	c798                	sw	a4,8(a5)
	*DMDATA1 = 0x00;
 222:	e00007b7          	lui	a5,0xe0000
 226:	3807a223          	sw	zero,900(a5) # e0000384 <_eusrstack+0xbfffb384>
	*DMDATA0 = 0x80;
 22a:	08000713          	li	a4,128
 22e:	38e7a023          	sw	a4,896(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 232:	8082                	ret

00000234 <main>:

void pin_init();
int read_databus();
void write_addressbus(int data);

int main() {
 234:	1141                	addi	sp,sp,-16
 236:	c606                	sw	ra,12(sp)
    SystemInit();
 238:	37e9                	jal	202 <SystemInit>
    funGpioInitAll(); // Enable GPIOs
 23a:	40021737          	lui	a4,0x40021
 23e:	4f1c                	lw	a5,24(a4)
 240:	01d7e793          	ori	a5,a5,29
 244:	cf1c                	sw	a5,24(a4)

    funDigitalWrite(BUS_ENABLE, FUN_LOW); // set BUS_ENABLE to low
 246:	400117b7          	lui	a5,0x40011
 24a:	c0078793          	addi	a5,a5,-1024 # 40010c00 <_eusrstack+0x2000bc00>
 24e:	10000737          	lui	a4,0x10000
 252:	cb98                	sw	a4,16(a5)
    write_addressbus(testaddr); // write  the address to the address bus
}

void pin_init() { // initializes extended databus GPIO pins
    for (int i = 16; i <= 24; i++) {
        int port_a_ext = GPIOA->CFGXR;
 254:	400117b7          	lui	a5,0x40011
    funDigitalWrite(BUS_ENABLE, FUN_LOW); // set BUS_ENABLE to low
 258:	4725                	li	a4,9
        int port_a_ext = GPIOA->CFGXR;
 25a:	80078793          	addi	a5,a5,-2048 # 40010800 <_eusrstack+0x2000b800>
 25e:	4fd4                	lw	a3,28(a5)
    for (int i = 16; i <= 24; i++) {
 260:	177d                	addi	a4,a4,-1 # fffffff <g6502_flashprog.c.a4e91263+0xfffe01b>
 262:	ff75                	bnez	a4,25e <main+0x2a>
    return databus_val; // return the combined data from the data bus
}

void write_addressbus(int address) {
    int flipped_addr = ((address & 0x1F) << 11) | ((address & 0xFFE0) << 15); // flip and shift address bits to match wiring
    GPIOA->OUTDR = (GPIOA->OUTDR & 0xF803FF) | flipped_addr; // set only the address bits in the GPIOA output data register
 264:	47d8                	lw	a4,12(a5)
 266:	00f806b7          	lui	a3,0xf80
 26a:	3ff68693          	addi	a3,a3,1023 # f803ff <g6502_flashprog.c.a4e91263+0xf7e41b>
}
 26e:	40b2                	lw	ra,12(sp)
    GPIOA->OUTDR = (GPIOA->OUTDR & 0xF803FF) | flipped_addr; // set only the address bits in the GPIOA output data register
 270:	8f75                	and	a4,a4,a3
 272:	0910a6b7          	lui	a3,0x910a
 276:	8f55                	or	a4,a4,a3
 278:	c7d8                	sw	a4,12(a5)
}
 27a:	4501                	li	a0,0
 27c:	0141                	addi	sp,sp,16
 27e:	8082                	ret
